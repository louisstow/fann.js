/*
** This script is generated by build script. Do not change it directly.
**
** The MIT License (MIT)
** 
** Copyright (c) 2015 Louis Stowasser
** 
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
** copies of the Software, and to permit persons to whom the Software is
** furnished to do so, subject to the following conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
** THE SOFTWARE.
*/

(function(exports) {
var mappings = {
	/* GLOBAL MAPPINGS */
	'create_standard_array': ['number', ['number', 'number'], 0],
	'read_train_from_file': ['number', ['string'], 0],
	'create_from_file': ['number', ['string'], 0],

	/* NETWORK MAPPINGS */
	'set_activation_steepness': [null, ['number', 'number', 'number', 'number'], 1],
	'set_activation_steepness_layer': [null, ['number', 'number', 'number'], 1],
	'set_activation_steepness_hidden': [null, ['number', 'number'], 1],
	'set_activation_steepness_output': [null, ['number', 'number'], 1],
	'set_activation_function': [null, ['number', 'number', 'number', 'number'], 1],
	'set_activation_function_layer': [null, ['number', 'number', 'number'], 1],
	'set_activation_function_hidden': [null, ['number', 'number'], 1],
	'set_activation_function_output': [null, ['number', 'number'], 1],
	'set_train_stop_function': [null, ['number', 'number'], 1],
	'set_train_error_function': [null, ['number', 'number'], 1],
	'set_bit_fail_limit': [null, ['number', 'number'], 1],
	'set_training_algorithm': [null, ['number', 'number'], 1],
	'set_learning_rate': [null, ['number', 'number'], 1],
	'set_learning_momentum': [null, ['number', 'number'], 1],
	'set_quickprop_decay': [null, ['number', 'number'], 2],
	'set_quickprop_mu': [null, ['number', 'number'], 2],

	'get_bit_fail': ['number', ['number'], 1],
	'get_bit_fail_limit': ['number', ['number'], 1],
	'get_MSE': ['number', ['number'], 1],
	'get_num_input': ['number', ['number'], 1],
	'get_num_output': ['number', ['number'], 1],
	'get_num_layers': ['number', ['number'], 1],
	'get_total_neurons': ['number', ['number'], 1],
	'get_total_connections': ['number', ['number'], 1],
	'get_network_type': ['number', ['number'], 1],
	'get_connection_rate': ['number', ['number'], 1],
	'get_training_algorithm': ['number', ['number'], 1],
	'get_learning_rate': ['number', ['number'], 1],
	'get_learning_momentum': ['number', ['number'], 1],
	'get_activation_function': ['number', ['number', 'number', 'number'], 1],
	'get_activation_steepness': ['number', ['number', 'number', 'number'], 1],
	'get_train_error_function': ['number', ['number'], 1],
	'get_quickprop_decay': ['number', ['number'], 2],
	'get_quickprop_mu': ['number', ['number'], 2],
	'reset_MSE': [null, ['number'], 1],

	'scale_train': [null, ['number', 'number'], 1],
	'descale_train': [null, ['number', 'number'], 1],
	'print_connections': [null, ['number'], 1],
	'print_parameters': [null, ['number'], 1],
	'train_on_data': [null, ['number', 'number', 'number', 'number'], 3],
	'init_weights': [null, ['number', 'number'], 3],
	'randomize_weights': [null, ['number', 'number', 'number'], 1],
	'test': ['number', ['number', 'number', 'number'], 1],
	'test_data': ['number', ['number', 'number'], 3],
	'train': ['number', ['number', 'number', 'number'], 1],
	'train_epoch': ['number', ['number', 'number'], 3],
	'run': ['number', ['number', 'number'], 1],
	'save': ['number', ['number', 'string'], 1],

	// cascade
	'cascadetrain_on_data': [null, ['number', 'number', 'number', 'number', 'number'], 3],
	'set_cascade_activation_steepnesses': [null, ['number', 'number', 'number'], 1],

	/* TRAINING DATA MAPPINGS */
	'shuffle_train_data': [null, ['number'], 2],
	'destroy_train': [null, ['number'], 2],
	'duplicate_train_data': ['number', ['number'], 2],
	'save_train': ['number', ['number', 'string'], 2],
	'length_train_data': ['number', ['number'], 2],
	'num_input_train_data': ['number', ['number'], 2],
	'num_output_train_data': ['number', ['number'], 2],
};
// Avatar represents objects at WebWorker on page context.
function avatarConstructor(initFn) {
    var C = function(worker, objID) {
        this.__doing = {};
        this.__worker = worker;
        this.__objID = objID;
        this.__worker.avatars[objID] = this;
        if(initFn) initFn();
    }

    C.prototype.getWorker = function(){ return this.__worker };

    C.prototype.__workerResponse = function(doID, error, response) {
        if (error) {
            error = 'FANN Worker fail to run ' + this.__doing[doID].method +
                    '(' + this.__doing[doID].args.join(', ') + '). Error: ' + error;
        }
        this.__doing[doID].fn(error, response);
        delete this.__doing[doID];
    };

    C.prototype.__workerDo = function(method, args, callback) {
        var doID = Math.random();
        this.__doing[doID] = { method:method, args:args, fn:callback };
        for (var i=0; i<args.length; i++) {
            if (args[i].__objID) args[i] = { avatarID: args[i].__objID };
        }
        this.__worker.postMessage({doID:doID, obj:this.__objID, method:method, args:args});
    };
    return C;
}


/* * *  Avatar for Network  * * */

var Network = avatarConstructor();

Network.prototype.getPointer = function (callback) {
    this.__workerDo('getPointer', [], callback);
}

Network.prototype.run = function (inputs, callback) {
    this.__workerDo('run', [inputs], callback);
};

Network.prototype.run_list = function (inputList, callback) {
    this.__workerDo('run_list', [inputList], callback);
};

Network.prototype.export = function (callback) {
    this.__workerDo('export', [], callback);
};


/* * *  Avatar for TrainingData  * * */

var TrainingData = avatarConstructor();

TrainingData.prototype.getPointer = function (callback) {
    this.__workerDo('getPointer', [], callback);
}

TrainingData.prototype.export = function (callback) {
    this.__workerDo('export', [], callback);
};


/* * *  Replaces the FANN object  * * */

// basePath discover allows to require fann.js from the right URI.
var basePath = './', scriptTags = document.getElementsByTagName('script');
for (var script,i=0; script=scriptTags[i]; i++) {
    if (script.src.indexOf('fann-factory.js')>-1) {
        basePath = script.src.replace(/\/[^\/]+$/, '/');
    }
}

// Build WebWorker, FANN avatar and calls back when FANN_ready() is called.
// This is the only directly accessible function on main context.
exports.createFANNWorker = function(callback) {
    var worker = new Worker(basePath + 'fann.js');
    worker.avatars = {};
    var fann = new FANN(worker, 0);
    worker.onmessage = function (msg) {
        obj = worker.avatars[msg.data.obj];
        obj.__workerResponse(msg.data.doID, msg.data.error, msg.data.response);
    }
    fann.__workerDo('whenReady', [], function(error, response){
        callback(error, fann);
    });
};

var FANN = avatarConstructor();

FANN.prototype.create = function (netDefinition, callback) {
    var me = this;
    this.__workerDo('create', [netDefinition], function(error, objID){
        if (error) callback(error);
        else {
            var ann = new Network(me.getWorker(), objID);
            ann.getPointer(function(err, pointer){
                ann.pointer = pointer;
                callback(err, ann);
            });
        }
    });
};

FANN.prototype.createTraining = function (data, callback) {
    var me = this;
    this.__workerDo('createTraining', [data], function(error, objID){
        if (error) callback(error);
        else {
            var td = new TrainingData(me.getWorker(), objID);
            td.getPointer(function(err, pointer){
                td.pointer = pointer;
                callback(err, td);
            });
        }
    });
};

function enums () {
    for (var i = 0; i < arguments.length; ++i) {
        FANN.prototype[arguments[i]] = i;
    }
}

// Do the FANN.init job. Add methods to constructors.
for (var method in mappings) {
    if (mappings[method][2] === 0) continue; // ignore that method.

    var Constructor = (mappings[method][2] === 2) ? TrainingData : Network;

    Constructor.prototype[method] = (function(method){
        return function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var callback = args.pop();
            if (typeof callback !== 'function') {
                throw new Error('The last parameter on fann-factory methods must be a callback function.');
            }
            this.__workerDo(method, args, callback);
        };
    })(method);
}
enums(
    "TRAIN_INCREMENTAL",
    "TRAIN_BATCH",
    "TRAIN_RPROP",
    "TRAIN_QUICKPROP",
    "TRAIN_SARPROP"
);

enums(
    "LINEAR",
    "THRESHOLD",
    "THRESHOLD_SYMMETRIC",
    "SIGMOID",
    "SIGMOID_STEPWISE",
    "SIGMOID_SYMMETRIC",
    "SIGMOID_SYMMETRIC_STEPWISE",
    "GAUSSIAN",
    "GAUSSIAN_SYMMETRIC",
    "GAUSSIAN_STEPWISE",
    "ELLIOT",
    "ELLIOT_SYMMETRIC",
    "LINEAR_PIECE",
    "LINEAR_PIECE_SYMMETRIC",
    "SIN_SYMMETRIC",
    "COS_SYMMETRIC",
    "SIN",
    "COS"
);

enums(
    "ERRORFUNC_LINEAR",
    "ERRORFUNC_TANH"
);

enums(
    "STOPFUNC_MSE",
    "STOPFUNC_BIT"
);

enums(
    "NETTYPE_LAYER",
    "NETTYPE_SHORTCUT"
);
})(window);
